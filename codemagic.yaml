workflows:
  expo-android-build:
    name: Expo Android Build
    max_build_duration: 120
    instance_type: linux_x2
    working_directory: chat-db-mobile
    environment:
      android_signing:
        - keystore_reference
      groups:
        - expo_credentials
      vars:
        EXPO_PUBLIC_API_URL: "https://meo-mv5n.onrender.com"
      node: 18.17.0
    triggering:
      events:
        - push
      branch_patterns:
        - pattern: main
          include: true
          source: true
    scripts:
      - name: Install dependencies
        script: |
          npm install --legacy-peer-deps
      - name: Install Expo CLI
        script: |
          npm install -g @expo/ngrok@^4.1.0
          npm install -g expo-cli
      - name: Prebuild Expo (generate native code)
        script: |
          npx expo prebuild --platform android --clean
      - name: Set Android SDK location
        script: |
          echo "sdk.dir=$ANDROID_SDK_ROOT" > "$CM_BUILD_DIR/android/local.properties"
      - name: Build Android APK
        script: |
          cd android
          ./gradlew assembleRelease --no-daemon
    artifacts:
      - android/app/build/outputs/**/*.apk
    publishing:
      email:
        recipients:
          - mehau5lucas@gmail.com
        notify:
          success: true
          failure: true

  expo-ios-build:
    name: Expo iOS Build for AltStore
    max_build_duration: 120
    instance_type: mac_mini_m1
    working_directory: chat-db-mobile
    environment:
      groups:
        - apple_credentials
      vars:
        EXPO_PUBLIC_API_URL: "https://meo-mv5n.onrender.com"
        BUNDLE_ID: "com.lychie5.meomobile"
      node: 18.17.0
      xcode: 16.1
    triggering:
      events:
        - push
      branch_patterns:
        - pattern: main
          include: true
          source: true
    scripts:
      - name: Install dependencies
        script: |
          npm install --legacy-peer-deps
      - name: Install Expo CLI and fastlane
        script: |
          npm install -g @expo/ngrok@^4.1.0
          npm install -g expo-cli
          gem install fastlane
      - name: Remove Push Notifications
        script: |
          node <<'EOF'
          const fs = require('fs');
          const appJson = JSON.parse(fs.readFileSync('app.json', 'utf8'));
          
          if (appJson.expo?.plugins) {
            appJson.expo.plugins = appJson.expo.plugins.filter(plugin => {
              const name = typeof plugin === 'string' ? plugin : plugin[0];
              return !name.includes('notification');
            });
          }
          
          if (appJson.expo?.ios?.infoPlist) {
            delete appJson.expo.ios.infoPlist.UIBackgroundModes;
          }
          
          fs.writeFileSync('app.json', JSON.stringify(appJson, null, 2));
          console.log('✓ Cleaned app.json');
          EOF
      - name: Prebuild Expo
        script: |
          npx expo prebuild --platform ios --clean
      - name: Detect project name
        script: |
          cd ios
          PROJECT=$(ls -d *.xcodeproj | head -n 1 | sed 's/\.xcodeproj$//')
          echo "XCODE_PROJECT=$PROJECT" >> $CM_ENV
          echo "✓ Project: $PROJECT"
          cd ..
      - name: Clean entitlements
        script: |
          find ios -name "*.entitlements" -delete
          echo "✓ Removed entitlements"
      - name: Check Podfile
        script: |
          cd ios
          echo "=== Checking Podfile ==="
          if [ -f "Podfile" ]; then
            echo "✓ Podfile exists"
            cat Podfile
          else
            echo "✗ Podfile NOT found!"
          fi
          cd ..
      - name: Install CocoaPods dependencies
        script: |
          cd ios
          
          # Add post_install hook to disable code signing for pods (single line)
          echo "" >> Podfile
          echo "post_install do |installer|" >> Podfile
          echo "  installer.pods_project.targets.each do |target|" >> Podfile
          echo "    target.build_configurations.each do |config|" >> Podfile
          echo "      config.build_settings['CODE_SIGNING_ALLOWED'] = 'NO'" >> Podfile
          echo "      config.build_settings['CODE_SIGNING_REQUIRED'] = 'NO'" >> Podfile
          echo "      config.build_settings['CODE_SIGN_IDENTITY'] = ''" >> Podfile
          echo "    end" >> Podfile
          echo "  end" >> Podfile
          echo "end" >> Podfile
          
          echo "=== Installing pods ==="
          pod install
          echo "=== Checking workspace ==="
          ls -la *.xcworkspace || echo "✗ No workspace found"
          ls -la
          cd ..
          echo "✓ Pods installed with signing disabled"
      - name: Build unsigned IPA
        script: |
          cd ios
          
          echo "=== Building app ==="
          # Build in Debug mode but force bundling like Release
          xcodebuild clean build \
            -workspace "$XCODE_PROJECT.xcworkspace" \
            -scheme "$XCODE_PROJECT" \
            -configuration Debug \
            -sdk iphoneos \
            -derivedDataPath ../build \
            -arch arm64 \
            ONLY_ACTIVE_ARCH=NO \
            VALID_ARCHS="arm64" \
            ARCHS="arm64" \
            SKIP_BUNDLING=NO \
            FORCE_BUNDLING=YES \
            CODE_SIGN_IDENTITY="" \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO \
            AD_HOC_CODE_SIGNING_ALLOWED=NO \
            ASSETCATALOG_COMPILER_GENERATE_ASSET_SYMBOLS=NO
          
          cd ..
          
          # Find .app bundle (Debug build)
          APP=$(find build/Build/Products/Debug-iphoneos -name "*.app" -type d | head -n 1)
          
          if [ -z "$APP" ]; then
            echo "✗ App bundle not found"
            exit 1
          fi
          
          echo "✓ App: $APP"
          
          echo "=== App contents (bundle already included by Xcode) ==="
          du -sh "$APP/"
          ls -lh "$APP/" | grep -E "main.jsbundle|meomobile|Info.plist|assets"
          
          # Verify bundle exists
          if [ -f "$APP/main.jsbundle" ]; then
            BUNDLE_SIZE=$(ls -lh "$APP/main.jsbundle" | awk '{print $5}')
            echo "✓ Bundle in app: $BUNDLE_SIZE"
            
            # Verify bundle is not empty and valid
            if [ -s "$APP/main.jsbundle" ]; then
              echo "✓ Bundle is not empty"
              head -c 100 "$APP/main.jsbundle" | od -c | head -5
            else
              echo "✗ Bundle is empty!"
              exit 1
            fi
          else
            echo "✗ Bundle NOT in app!"
            exit 1
          fi
          
          # Ensure Info.plist is valid
          if [ ! -f "$APP/Info.plist" ]; then
            echo "✗ Missing Info.plist"
            exit 1
          fi
          
          echo "=== Info.plist details ==="
          /usr/libexec/PlistBuddy -c "Print CFBundleIdentifier" "$APP/Info.plist"
          /usr/libexec/PlistBuddy -c "Print CFBundleExecutable" "$APP/Info.plist"
          /usr/libexec/PlistBuddy -c "Print CFBundleName" "$APP/Info.plist"
          /usr/libexec/PlistBuddy -c "Print CFBundleDisplayName" "$APP/Info.plist" 2>/dev/null || echo "No display name"
          
          # Fix bundle display name
          /usr/libexec/PlistBuddy -c "Set :CFBundleDisplayName meomobile" "$APP/Info.plist" 2>/dev/null || \
          /usr/libexec/PlistBuddy -c "Add :CFBundleDisplayName string meomobile" "$APP/Info.plist"
          
          echo "✓ Info.plist configured"
          
          # Check binary architecture
          EXEC_NAME=$(/usr/libexec/PlistBuddy -c "Print CFBundleExecutable" "$APP/Info.plist")
          echo "=== Binary architecture ==="
          file "$APP/$EXEC_NAME"
          lipo -info "$APP/$EXEC_NAME" 2>/dev/null || echo "Not a fat binary"
          
          # Read bundle ID from Info.plist
          BUNDLE=$(/usr/libexec/PlistBuddy -c "Print CFBundleIdentifier" "$APP/Info.plist" 2>/dev/null || echo "com.lychie5.meomobile")
          echo "✓ Bundle ID: $BUNDLE"
          
          # Strip any existing code signature to allow AltStore to re-sign
          echo "=== Removing code signature ==="
          rm -rf "$APP/_CodeSignature" 2>/dev/null || true
          rm -f "$APP/embedded.mobileprovision" 2>/dev/null || true
          
          # Strip signatures from all dylibs and frameworks
          find "$APP/Frameworks" -name "*.dylib" -o -name "*.framework" 2>/dev/null | while read file; do
            if [ -f "$file" ]; then
              codesign --remove-signature "$file" 2>/dev/null || true
            fi
          done
          
          # Strip signature from main executable
          EXEC_NAME=$(/usr/libexec/PlistBuddy -c "Print CFBundleExecutable" "$APP/Info.plist")
          if [ -f "$APP/$EXEC_NAME" ]; then
            codesign --remove-signature "$APP/$EXEC_NAME" 2>/dev/null || true
            echo "✓ Signature removed from $EXEC_NAME"
          fi
          
          echo "✓ All signatures removed"
          
          # Create IPA structure
          rm -rf Payload
          mkdir Payload
          cp -R "$APP" Payload/
          
          echo "=== Payload size ==="
          du -sh Payload/
          ls -lh Payload/
          
          # Create IPA with proper compression
          # Use -1 for fast compression (preserves file size better)
          zip -1 -r meomobile.ipa Payload
          
          # Move to artifacts
          mv meomobile.ipa build/
          
          IPA_SIZE=$(ls -lh build/meomobile.ipa | awk '{print $5}')
          echo "✓ IPA created: $IPA_SIZE"
          
          rm -rf Payload
          
          # Validate IPA
          if [ -f "build/meomobile.ipa" ]; then
            echo "✓ IPA created: $(ls -lh build/meomobile.ipa | awk '{print $5}')"
            
            # Quick check
            unzip -l build/meomobile.ipa | grep -q "Payload/.*\.app/Info.plist" && echo "✓ Valid structure" || echo "✗ Invalid structure"
          else
            echo "✗ IPA creation failed"
            exit 1
          fi
    artifacts:
      - build/meomobile.ipa
    publishing:
      email:
        recipients:
          - mehau5lucas@gmail.com
        notify:
          success: true
          failure: true
